Music Editor Design Modification Decisions
Nicholas Flanders
Perry Dai



Changes:

Before implementing the views for our music editor, we decided to make some modifications
to the design of our model. First, we decided to make a Playable interface that our Note
class would implement instead of directly exposing the concrete Note class. This allowed us
to hide the detail of how notes were implemented specifically. Additionally, we needed to
add the ability to get and set volume and instrument IDs to our Playable interface as we
realized that this data would be important for rendering a MIDI view.

Another significant change that we made to our model was to switch from a List<Note> in our
composition representation to a Map<Integer, List<Playable>> where the keys of this map
correspond to a beat number in the song and the list contains references to all of the notes
either sustaining or beginning during that beat. It can be easily determined by a view
whether a note is beginning or sustaining by simply comparing the start beat that is stored in
the note itself to the beat number that was used to retrieve the list that the beat was found
in. Additionally, we added methods on our MusicEditorModel interface to return references to the
lowest and highest notes found in a song. We originally thought that this information should be
determined by the views if necessary, but we decided to put it in the model since this data
is required by many types of models that are designed to visualize data.



Final Design Description:

Our final design includes a MusicEditorModel interface to represent musical compositions and the
Song class serves as the concrete implementation of this interface. Notes are represented through
the Playable interface and their concrete implementation is found in the Note class. All Playables
track all of the data necessary to render them, including their pitch, octave, start beat,
duration, instrument ID, and volume. Pitches are represented by an Enum which also contains
several convenience methods for converting to and from MIDI values.

The views for our music editor all implement the View interface, which allows a client to render
a model with the given view and to change the model associated with that view. The ConsoleView
class implements View in order to return a vertical ASCII representation of the model contained
within that view. The MainGUI class is a view that uses JavaFX to render a graphical view of a
model. Because JavaFX applications are always created by calling a default constructor that takes
no arguments, there is a static field on that class with a reference to a model that will be
rendered and this model is then assigned to a non-static field for each instance of that class.
The class GUIConstants is a wrapper class containing configuration constants for this JavaFX UI.
Finally, the MidiView class implements the View interface in such a way that the model contained
within it is rendered audibly through MIDI. All of these views can be constructed through the
ViewFactory class which contains a method that returns various types of views based on a String
argument passed to it.



*************************************************
NEWLY ADDED FOR ASSIGNMENT 7:

 - refactor render method on View interface to take a timestamp to render at